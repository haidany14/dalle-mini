===== FILE BEGIN =====
PATH: bot-hub/main.py
MODE: 0644
SHA256: AUTO
-----8<----- START CONTENT -----8<-----
from __future__ import annotations

import os
import time
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from .schemas import StatusResponse

# Start time for uptime calculation
START_TIME = time.time()


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print(f"Starting Bot-Hub on port {os.getenv('PORT', '8080')}")
    yield
    # Shutdown
    print("Shutting down Bot-Hub")


app = FastAPI(
    title="Bot-Hub",
    version="1.0.3",
    lifespan=lifespan
)

# CORS configuration
cors_origins = os.getenv("CORS_ORIGINS", "").split(",")
cors_origins = [origin.strip() for origin in cors_origins if origin.strip()]
if cors_origins:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )


@app.get("/health")
async def health():
    return {"status": "ok"}


@app.get("/ready")
async def ready():
    return {"ready": True}


@app.get("/api/v1/status")
async def status() -> StatusResponse:
    return StatusResponse(
        app="bot-hub",
        version="1.0.3",
        uptime=time.time() - START_TIME
    )


# Import routers with fallback
try:
    from .api_gateway import gateway_router
except ImportError:
    from .component_stubs import gateway_router

try:
    from .delivery import deliver_router
except ImportError:
    from .component_stubs import deliver_router

try:
    from .telegram import telegram_router
except ImportError:
    from .component_stubs import telegram_router

# Include routers
app.include_router(gateway_router)
app.include_router(deliver_router)
app.include_router(telegram_router)


# Global exception handler
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error", "code": "internal_error"}
    )
-----8<----- END CONTENT -----8<-----
===== FILE END =====
===== FILE BEGIN =====
PATH: bot-hub/schemas.py
MODE: 0644
SHA256: AUTO
-----8<----- START CONTENT -----8<-----
from __future__ import annotations

from typing import Optional

from pydantic import BaseModel


class StatusResponse(BaseModel):
    app: str
    version: str
    uptime: float


class ErrorResponse(BaseModel):
    detail: str
    code: Optional[str] = None


class UploadResponse(BaseModel):
    id: str
    size: int
    mime: Optional[str] = None


class RateLimitInfo(BaseModel):
    limit: int
    remaining: int
    reset: int


class TelegramUpdate(BaseModel):
    update_id: int
    message: Optional[dict] = None
    edited_message: Optional[dict] = None
-----8<----- END CONTENT -----8<-----
===== FILE END =====
===== FILE BEGIN =====
PATH: bot-hub/auth_guards.py
MODE: 0644
SHA256: AUTO
-----8<----- START CONTENT -----8<-----
from __future__ import annotations

import hashlib
import hmac
import ipaddress
import os
from dataclasses import dataclass
from typing import Optional

from fastapi import HTTPException, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials


security = HTTPBearer()


@dataclass
class AuthInfo:
    who: str
    method: str


async def api_key_guard(credentials: HTTPAuthorizationCredentials = security) -> AuthInfo:
    """Verify API key from Authorization: Bearer <token>"""
    api_key = os.getenv("API_KEY", "")
    if not api_key:
        raise HTTPException(status_code=401, detail="API key not configured")
    
    if credentials.credentials != api_key:
        raise HTTPException(status_code=401, detail="Invalid API key")
    
    return AuthInfo(who="api-key", method="bearer")


async def hmac_guard(request: Request) -> AuthInfo:
    """Verify HMAC SHA256 signature from X-Signature header"""
    secret = os.getenv("HMAC_SECRET", "")
    if not secret:
        raise HTTPException(status_code=401, detail="HMAC secret not configured")
    
    signature_header = request.headers.get("X-Signature", "")
    if not signature_header:
        raise HTTPException(status_code=401, detail="Missing signature header")
    
    body_bytes = await request.body()
    expected_sig = hmac.new(
        secret.encode(),
        body_bytes,
        hashlib.sha256
    ).hexdigest()
    
    if not hmac.compare_digest(signature_header, expected_sig):
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    return AuthInfo(who="hmac", method="sha256")


async def ip_filter_guard(request: Request) -> AuthInfo:
    """Enforce IP filtering based on ALLOWED_IPS and BLOCKED_IPS"""
    client_ip = request.client.host if request.client else ""
    
    # Check blocked IPs first
    blocked_ips = os.getenv("BLOCKED_IPS", "").split(",")
    blocked_ips = [ip.strip() for ip in blocked_ips if ip.strip()]
    
    for blocked in blocked_ips:
        try:
            if "/" in blocked:
                # CIDR notation
                network = ipaddress.ip_network(blocked, strict=False)
                if ipaddress.ip_address(client_ip) in network:
                    raise HTTPException(status_code=403, detail="IP blocked")
            else:
                # Single IP
                if client_ip == blocked:
                    raise HTTPException(status_code=403, detail="IP blocked")
        except ValueError:
            # Skip invalid entries
            continue
    
    # Check allowed IPs
    allowed_ips = os.getenv("ALLOWED_IPS", "").split(",")
    allowed_ips = [ip.strip() for ip in allowed_ips if ip.strip()]
    
    if allowed_ips:
        allowed = False
        for allowed_ip in allowed_ips:
            try:
                if "/" in allowed_ip:
                    # CIDR notation
                    network = ipaddress.ip_network(allowed_ip, strict=False)
                    if ipaddress.ip_address(client_ip) in network:
                        allowed = True
                        break
                else:
                    # Single IP
                    if client_ip == allowed_ip:
                        allowed = True
                        break
            except ValueError:
                # Skip invalid entries
                continue
        
        if not allowed:
            raise HTTPException(status_code=403, detail="IP not allowed")
    
    return AuthInfo(who=client_ip, method="ip-filter")
-----8<----- END CONTENT -----8<-----
===== FILE END =====
===== FILE BEGIN =====
PATH: bot-hub/mesh_client.py
MODE: 0644
SHA256: AUTO
-----8<----- START CONTENT -----8<-----
from __future__ import annotations

import ipaddress
import os
from typing import Optional
from urllib.parse import urlparse

import httpx
from fastapi import HTTPException


_client: Optional[httpx.AsyncClient] = None


def get_client() -> httpx.AsyncClient:
    """Get singleton HTTP client instance"""
    global _client
    if _client is None:
        _client = httpx.AsyncClient(
            timeout=10.0,
            follow_redirects=False
        )
    return _client


async def invoke(method: str, url: str, **kwargs) -> httpx.Response:
    """Make HTTP request with SSRF protection"""
    # Parse URL
    try:
        parsed = urlparse(url)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid URL")
    
    # Check scheme
    if parsed.scheme not in ("http", "https"):
        raise HTTPException(status_code=400, detail="Only HTTP/HTTPS allowed")
    
    # Get allowed upstreams
    allowed_upstreams = os.getenv("ALLOWED_UPSTREAMS", "").split(",")
    allowed_upstreams = [upstream.strip() for upstream in allowed_upstreams if upstream.strip()]
    
    if not allowed_upstreams:
        raise HTTPException(status_code=503, detail="No upstream hosts configured")
    
    # Check if host is allowed
    if parsed.hostname not in allowed_upstreams:
        raise HTTPException(status_code=403, detail="Host not in allowlist")
    
    # Check for private IP ranges
    try:
        ip = ipaddress.ip_address(parsed.hostname)
        if ip.is_private or ip.is_loopback or ip.is_link_local:
            raise HTTPException(status_code=403, detail="Private IP ranges not allowed")
    except ValueError:
        # Not an IP address, hostname is okay
        pass
    
    # Make request
    client = get_client()
    try:
        response = await client.request(method, url, **kwargs)
        response.raise_for_status()
        return response
    except httpx.HTTPStatusError as e:
        raise HTTPException(
            status_code=502,
            detail=f"Upstream error: {e.response.status_code}"
        )
    except httpx.RequestError as e:
        raise HTTPException(
            status_code=502,
            detail=f"Upstream connection error"
        )
    except Exception:
        raise HTTPException(
            status_code=502,
            detail="Upstream request failed"
        )
-----8<----- END CONTENT -----8<-----
===== FILE END =====
===== FILE BEGIN =====
PATH: bot-hub/component_stubs.py
MODE: 0644
SHA256: AUTO
-----8<----- START CONTENT -----8<-----
from __future__ import annotations

from fastapi import APIRouter, Path
from fastapi.responses import JSONResponse


gateway_router = APIRouter(prefix="/api/gateway")
deliver_router = APIRouter(prefix="/api/delivery")
telegram_router = APIRouter(prefix="/api/telegram")


@gateway_router.post("/route/{path:path}")
async def gateway_route(path: str = Path(...)):
    return JSONResponse(
        status_code=501,
        content={"detail": "Not implemented in this part"}
    )


@deliver_router.post("/upload")
async def delivery_upload():
    return JSONResponse(
        status_code=501,
        content={"detail": "Not implemented in this part"}
    )


@deliver_router.get("/status/{id}")
async def delivery_status(id: str):
    return JSONResponse(
        status_code=501,
        content={"detail": "Not implemented in this part"}
    )


@telegram_router.post("/webhook")
async def telegram_webhook():
    return JSONResponse(
        status_code=501,
        content={"detail": "Not implemented in this part"}
    )


@telegram_router.get("/status")
async def telegram_status():
    return JSONResponse(
        status_code=501,
        content={"detail": "Not implemented in this part"}
    )
-----8<----- END CONTENT -----8<-----
===== FILE END =====